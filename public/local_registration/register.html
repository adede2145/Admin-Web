<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Register Employee</title>
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    
    <style>
        :root {
            --aa-maroon: #560000;
            --aa-maroon-dark: #3a0000;
            --aa-yellow: #ffc107;
        }

        body {
            background: #d1d5db url('../login-bg.jpg') center/cover no-repeat fixed;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            padding: 20px;
        }

        .container-wrapper {
            max-width: 1200px;
            margin: 0 auto;
        }

        .aa-card {
            background: #fff;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15), 0 2px 8px rgba(0,0,0,0.1);
        }

        .aa-card .card-body {
            padding: 1.5rem;
        }

        .header-maroon {
            background: var(--aa-maroon) !important;
            color: #fff !important;
            padding: 0.9rem 1.25rem;
            min-height: 56px;
            display: flex;
            align-items: center;
            border-radius: 0.5rem 0.5rem 0 0;
        }

        .card-title {
            font-size: 1.15rem;
            font-weight: 700;
            margin: 0;
        }

        .card-title i {
            font-size: 1.25rem;
        }

        .fingerprint-section {
            transition: all 0.3s ease;
        }

        .fingerprint-section.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .progress-wrapper {
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .notification {
            animation: slideInRight 0.3s ease-out;
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(100%);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .status-text {
            font-weight: 500;
            transition: color 0.2s ease;
        }

        .device-status {
            padding: 8px 12px;
            border-radius: 6px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
        }

        .alert-info {
            background: #cfe2ff;
            border-color: #b6d4fe;
            color: #084298;
        }
    </style>
</head>
<body>
    <div class="container-wrapper">
        <div class="row">
            <div class="col-12">
                <div class="card aa-card">
                    <div class="card-header header-maroon d-flex justify-content-between align-items-center">
                        <div class="card-title m-0">
                            <i class="bi bi-person-plus me-2"></i> Register Employee
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="mb-3">
                            <div class="d-flex align-items-center gap-2 device-status">
                                <i class="bi bi-usb-symbol text-secondary"></i>
                                <span id="deviceStatus" class="text-muted status-text">Checking Device Bridge...</span>
                            </div>
                        </div>

                        <form id="registerForm">
                            <div class="row g-3">
                                <div class="col-md-4">
                                    <label class="form-label">Profile Image</label>
                                    <input type="file" class="form-control" id="profileImage" name="profile_image" accept="image/*">
                                    <div class="mt-2">
                                        <img id="profilePreview" src="" alt="Preview" class="img-thumbnail d-none" style="max-width: 180px;">
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <label class="form-label">Employee Name <span class="text-danger">*</span></label>
                                    <input type="text" class="form-control" id="empName" name="emp_name" placeholder="Full name" required>
                                </div>
                                <div class="col-md-4">
                                    <label class="form-label">Employee ID <span class="text-danger">*</span></label>
                                    <input type="text" class="form-control" id="empId" name="emp_id" placeholder="ID/Code" required>
                                </div>

                                <div class="col-md-4">
                                    <label class="form-label">Office <span class="text-danger">*</span></label>
                                    <select id="departmentId" name="department_id" class="form-select" required>
                                        <option value="">Loading offices...</option>
                                    </select>
                                </div>

                                <div class="col-md-4">
                                    <label class="form-label">Employment Type <span class="text-danger">*</span></label>
                                    <select id="employmentType" name="employment_type" class="form-select" required>
                                        <option value="">Select employment type</option>
                                        <option value="full_time">Full Time</option>
                                        <option value="part_time">Part Time</option>
                                    </select>
                                </div>

                                <div class="col-md-4">
                                    <label class="form-label">RFID (fallback) <span class="text-danger">*</span> <span id="rfidStatus" class="ms-2 small text-muted"></span></label>
                                    <div class="input-group">
                                        <input type="text" class="form-control" id="rfidUid" name="rfid_uid" placeholder="Tap card or type UID" autocomplete="off">
                                        <button class="btn btn-outline-primary" type="button" id="clearRfidBtn">Clear</button>
                                    </div>
                                    <div class="form-text">If your reader is keyboard-wedge, focus here and tap a card.</div>
                                </div>

                                <div class="col-md-6">
                                    <label class="form-label">Fingerprint Enrollment</label>

                                    <!-- Primary Fingerprint Section -->
                                    <div class="border rounded p-3 mb-3 bg-light">
                                        <h6 class="text-primary mb-2">
                                            <i class="bi bi-1-circle me-1"></i> Primary Fingerprint (Index Finger) <span class="text-danger" id="primaryRequired">*</span>
                                        </h6>
                                        <div class="d-flex flex-wrap align-items-center gap-2 mb-2">
                                            <!-- Toggle for edit mode -->
                                            <div class="form-check form-switch me-2 d-none" id="replacePrimaryToggleContainer">
                                                <input class="form-check-input" type="checkbox" id="replacePrimaryToggle">
                                                <label class="form-check-label" for="replacePrimaryToggle">Replace primary template</label>
                                            </div>
                                            <button type="button" id="capturePrimaryBtn" class="btn btn-outline-primary btn-sm" disabled>
                                                <i class="bi bi-fingerprint me-1"></i> Scan Primary
                                            </button>
                                            <span id="primaryStatus" class="text-muted">Waiting for Device Bridge...</span>
                                        </div>
                                        <!-- Scanning Progress for Primary -->
                                        <div id="primaryProgress" class="d-none progress-wrapper">
                                            <div class="d-flex align-items-center gap-2 mb-2">
                                                <div class="spinner-border spinner-border-sm text-primary" role="status"></div>
                                                <span class="small text-primary">Scanning in progress...</span>
                                            </div>
                                            <div class="progress mb-2" style="height: 6px;">
                                                <div id="primaryProgressBar" class="progress-bar progress-bar-striped progress-bar-animated"
                                                    role="progressbar" style="width: 0%"></div>
                                            </div>
                                            <div class="small text-muted">
                                                <span id="primaryInstruction">Place your index finger on the scanner...</span>
                                            </div>
                                        </div>
                                        <input type="hidden" id="primaryTemplate" name="primary_template" value="">
                                    </div>

                                    <!-- Backup Fingerprint Section -->
                                    <div class="border rounded p-3 bg-light" id="backupSection" style="opacity: 0.5;">
                                        <h6 class="text-secondary mb-2">
                                            <i class="bi bi-2-circle me-1"></i> Backup Fingerprint (Thumb)
                                        </h6>
                                        <div class="d-flex flex-wrap align-items-center gap-2 mb-2">
                                            <!-- Toggle for edit mode -->
                                            <div class="form-check form-switch me-2 d-none" id="replaceBackupToggleContainer">
                                                <input class="form-check-input" type="checkbox" id="replaceBackupToggle">
                                                <label class="form-check-label" for="replaceBackupToggle">Replace backup template</label>
                                            </div>
                                            <button type="button" id="captureBackupBtn" class="btn btn-outline-secondary btn-sm" disabled>
                                                <i class="bi bi-fingerprint me-1"></i> Scan Backup
                                            </button>
                                            <span id="backupStatus" class="text-muted">Complete primary fingerprint first</span>
                                        </div>
                                        <!-- Scanning Progress for Backup -->
                                        <div id="backupProgress" class="d-none progress-wrapper">
                                            <div class="d-flex align-items-center gap-2 mb-2">
                                                <div class="spinner-border spinner-border-sm text-secondary" role="status"></div>
                                                <span class="small text-secondary">Scanning in progress...</span>
                                            </div>
                                            <div class="progress mb-2" style="height: 6px;">
                                                <div id="backupProgressBar" class="progress-bar progress-bar-striped progress-bar-animated bg-secondary"
                                                    role="progressbar" style="width: 0%"></div>
                                            </div>
                                            <div class="small text-muted">
                                                <span id="backupInstruction">Place your thumb on the scanner...</span>
                                            </div>
                                        </div>
                                        <input type="hidden" id="backupTemplate" name="backup_template" value="">
                                    </div>

                                    <!-- Overall Status -->
                                    <div class="mt-3">
                                        <span id="fpOverallStatus" class="text-muted">Device status checking...</span>
                                    </div>
                                </div>

                                <div class="col-12">
                                    <button id="registerBtn" type="submit" class="btn btn-primary" disabled>
                                        <i class="bi bi-check2-circle me-1"></i> Register Employee
                                    </button>
                                    <button id="cancelBtn" type="button" class="btn btn-outline-secondary">
                                        <i class="bi bi-x-circle me-1"></i> Cancel
                                    </button>
                                    <span id="registerHint" class="ms-2 text-muted"></span>
                                </div>
                            </div>
                        </form>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        // Get URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const mode = urlParams.get('mode'); // 'edit' or null (for new registration)
        const employeeId = urlParams.get('employee_id');
        const token = urlParams.get('token');
        const backendUrl = urlParams.get('backend') || 'http://localhost/Admin-Web/public';

        // Configure based on mode
        if (mode === 'edit' && employeeId) {
            // EDIT MODE - Load existing employee data
            document.title = 'Edit Employee Fingerprints';
            // Load employee data and show replace fingerprint UI
            loadEmployeeForEdit(employeeId);
        } else {
            // NEW REGISTRATION MODE
            document.title = 'Register Employee';
            // Show new employee form
        }

        async function loadEmployeeForEdit(id) {
            try {
                const response = await fetch(`${backendUrl}/api/employees/${id}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Accept': 'application/json'
                    }
                });
                
                const employee = await response.json();
                // Populate form with existing data
                // ...
            } catch (error) {
                console.error('Failed to load employee:', error);
            }
        }

        // ============================================================
        // CONFIGURATION: Backend URL and Authentication Token
        // ============================================================
        let bridgeBase = 'http://127.0.0.1:18420';
        
        /**
         * Extract token from URL query parameter
         */
        function getTokenFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');
            // URLSearchParams automatically decodes, but let's make sure
            return token ? decodeURIComponent(token) : null;
        }

        /**
         * Extract mode from URL query parameter
         */
        function getModeFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('mode');
        }

        /**
         * Extract employee ID from URL query parameter
         */
        function getEmployeeIdFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('employee_id');
        }

        /**
         * Check if we're in edit mode
         */
        function isEditMode() {
            return getModeFromUrl() === 'edit';
        }

        /**
         * Get the backend API URL from URL parameter or use default
         * Priority: URL parameter > localStorage > hardcoded default
         */
        function getBackendUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            const backendFromUrl = urlParams.get('backend');
            
            if (backendFromUrl) {
                // Use the backend URL passed from the web app
                localStorage.setItem('backendUrl', backendFromUrl);
                return backendFromUrl;
            }
            
            // Try localStorage
            const storedBackend = localStorage.getItem('backendUrl');
            if (storedBackend) {
                return storedBackend;
            }
            
            // Fallback to default (update this for your production backend)
            return 'http://localhost/Admin-Web/public';
        }

        /**
         * Get the admin authentication token from URL or localStorage
         * Priority: URL token > localStorage
         * This token is required for RBAC and authenticating API requests
         */
        function getAuthToken() {
            // First, check URL parameter
            const urlToken = getTokenFromUrl();
            if (urlToken) {
                saveAuthToken(urlToken);
                return urlToken;
            }
            
            // Try localStorage
            const token = localStorage.getItem('adminToken') || '';
            
            return token;
        }

        /**
         * Save auth token to localStorage for persistence across page reloads
         */
        function saveAuthToken(token) {
            if (token) {
                localStorage.setItem('adminToken', token);
            }
        }

        /**
         * Clear stored authentication token
         */
        function clearAuthToken() {
            localStorage.removeItem('adminToken');
        }

        // ============================================================
        // OFFICE DATA MANAGEMENT: Dynamic loading from backend
        // ============================================================
        
        /**
         * Validate token with backend API
         * Returns admin details if token is valid
         */
        async function validateTokenWithBackend() {
            const backendUrl = getBackendUrl();
            const token = getAuthToken();

            console.log('=== Token Validation Debug ===');
            console.log('Backend URL:', backendUrl);
            console.log('Token (first 50 chars):', token ? token.substring(0, 50) + '...' : 'null');
            console.log('Token length:', token ? token.length : 0);

            if (!token) {
                console.error('No token found!');
                return null;
            }

            try {
                const requestBody = { token: token };
                console.log('Sending validation request...');
                
                const response = await fetch(`${backendUrl}/api/validate-token`, {
                    method: 'POST',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify(requestBody),
                    signal: AbortSignal.timeout(10000)
                });

                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Response data:', data);

                if (response.ok && data.success) {
                    console.log('✅ Token validated successfully!');
                    return data.admin;
                } else {
                    console.error('❌ Token validation failed:', data.message || 'Unknown error');
                }
                
                return null;
            } catch (error) {
                console.error('❌ Token validation error:', error);
                return null;
            }
        }
        
        /**
         * Fetch offices/departments from the hosted Laravel backend
         * Respects RBAC: Super Admin sees all offices, Admin sees only their office(s)
         * Uses token-based authentication (no separate login required)
         */
        async function loadOfficesFromBackend() {
            const backendUrl = getBackendUrl();
            const token = getAuthToken();
            const officeSelect = document.getElementById('departmentId');

            // Validate token exists
            if (!token) {
                officeSelect.innerHTML = '<option value="">Not authenticated</option>';
                officeSelect.disabled = true;
                return false;
            }

            // Show loading state
            officeSelect.innerHTML = '<option value="">Loading offices...</option>';
            officeSelect.disabled = true;

            // First, validate the token
            const adminDetails = await validateTokenWithBackend();
            
            if (!adminDetails) {
                clearAuthToken();
                officeSelect.innerHTML = '<option value="">Session expired</option>';
                officeSelect.disabled = true;
                return false;
            }

            // Now fetch offices
            officeSelect.innerHTML = '<option value="">Loading offices...</option>';

            try {
                console.log('Fetching offices from:', `${backendUrl}/api/offices`);

                // Make authenticated request to backend using token
                const response = await fetch(`${backendUrl}/api/offices?token=${encodeURIComponent(token)}`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    signal: AbortSignal.timeout(10000)
                });

                console.log('Response status:', response.status);

                // Handle authentication errors
                if (response.status === 401 || response.status === 403) {
                    officeSelect.innerHTML = '<option value="">Not authorized</option>';
                    officeSelect.disabled = true;
                    clearAuthToken();
                    return false;
                }

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('Offices data received:', data);

                // Handle response structure
                let offices = [];
                if (data.success && Array.isArray(data.offices)) {
                    offices = data.offices;
                } else if (Array.isArray(data)) {
                    offices = data;
                } else if (data.data && Array.isArray(data.data)) {
                    offices = data.data;
                } else {
                    throw new Error('Invalid response format from backend');
                }

                // Validate we have offices
                if (offices.length === 0) {
                    officeSelect.innerHTML = '<option value="">No offices available</option>';
                    officeSelect.disabled = true;
                    return false;
                }

                // Populate dropdown with offices
                officeSelect.innerHTML = '<option value="">Select office</option>';
                offices.forEach(office => {
                    const option = document.createElement('option');
                    option.value = office.id || office.department_id || office.office_id;
                    option.textContent = office.name || office.department_name || office.office_name || `Office ${option.value}`;
                    officeSelect.appendChild(option);
                });

                // Handle office selection based on admin role
                if (data.admin_role === 'super_admin') {
                    // Super admin: keep dropdown enabled with all offices
                    officeSelect.disabled = false;
                } else {
                    // Regular admin: auto-select their office and lock it
                    if (offices.length === 1) {
                        officeSelect.value = offices[0].id || offices[0].department_id || offices[0].office_id;
                        officeSelect.disabled = true;
                    } else if (offices.length > 1) {
                        // If admin has multiple offices, select first one and lock
                        officeSelect.value = offices[0].id || offices[0].department_id || offices[0].office_id;
                        officeSelect.disabled = true;
                    }
                }

                // Token is valid, keep it
                saveAuthToken(token);

                return true;

            } catch (error) {
                console.error('Failed to load offices:', error);
                
                officeSelect.innerHTML = '<option value="">Connection failed</option>';
                officeSelect.disabled = true;

                return false;
            }
        }

        // Initialize department ID from config (legacy support - will be replaced by dynamic loading)
        function initializeDepartment() {
            // This function is now deprecated in favor of loadOfficesFromBackend()
            // Kept for backward compatibility during transition
            console.log('Legacy initializeDepartment() called - use loadOfficesFromBackend() instead');
        }

        /**
         * Load employee data for edit mode
         */
        async function loadEmployeeData() {
            const backendUrl = getBackendUrl();
            const token = getAuthToken();
            const employeeId = getEmployeeIdFromUrl();

            if (!employeeId) {
                console.error('No employee ID provided for edit mode');
                showNotification('Error', 'No employee ID provided', 'error');
                return;
            }

            console.log('Loading employee data for ID:', employeeId);

            try {
                const response = await fetch(`${backendUrl}/api/get-employee`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                    },
                    body: JSON.stringify({
                        token: token,
                        employee_id: employeeId
                    })
                });

                const data = await response.json();

                if (data.success && data.employee) {
                    const emp = data.employee;
                    
                    // Populate form fields (read-only)
                    document.getElementById('empName').value = emp.full_name;
                    document.getElementById('empName').readOnly = true;
                    
                    document.getElementById('empId').value = emp.employee_code || emp.employee_id;
                    document.getElementById('empId').readOnly = true;
                    
                    document.getElementById('rfidUid').value = emp.rfid_code;
                    document.getElementById('rfidUid').readOnly = true;
                    
                    document.getElementById('employmentType').value = emp.employment_type;
                    document.getElementById('employmentType').disabled = true;
                    
                    // Load offices first, then set department
                    await loadOfficesFromBackend();
                    document.getElementById('departmentId').value = emp.department_id;
                    document.getElementById('departmentId').disabled = true;
                    
                    // Update profile image preview
                    if (emp.photo_url) {
                        document.getElementById('profilePreview').src = emp.photo_url;
                        document.getElementById('profilePreview').classList.remove('d-none');
                    }
                    
                    // Hide profile image upload in edit mode
                    document.getElementById('profileImage').disabled = true;
                    document.getElementById('profileImage').style.display = 'none';
                    
                    // Update UI for edit mode
                    document.querySelector('.card-title').innerHTML = `<i class="bi bi-fingerprint me-2"></i>Edit Employee Fingerprints - ${emp.full_name}`;
                    document.getElementById('registerBtn').textContent = 'Update Fingerprints';
                    document.getElementById('registerBtn').innerHTML = '<i class="bi bi-fingerprint me-2"></i>Update Fingerprints';
                    
                    // Show toggle checkboxes in edit mode
                    document.getElementById('replacePrimaryToggleContainer').classList.remove('d-none');
                    document.getElementById('replaceBackupToggleContainer').classList.remove('d-none');
                    
                    // Remove required indicator from primary fingerprint in edit mode
                    document.getElementById('primaryRequired').classList.add('d-none');
                    
                    // Hide finger type labels (Index Finger) and (Thumb) in edit mode
                    const primaryHeading = document.querySelector('.text-primary.mb-2');
                    if (primaryHeading) {
                        primaryHeading.innerHTML = '<i class="bi bi-1-circle me-1"></i> Primary Fingerprint';
                    }
                    
                    const backupHeading = document.querySelector('.text-secondary.mb-2');
                    if (backupHeading) {
                        backupHeading.innerHTML = '<i class="bi bi-2-circle me-1"></i> Backup Fingerprint';
                    }
                    
                    // Update fingerprint status and DISABLE buttons by default
                    if (emp.has_primary_fingerprint) {
                        document.getElementById('capturePrimaryBtn').textContent = 'Replace Primary';
                        document.getElementById('capturePrimaryBtn').disabled = true; // Disabled by default
                        document.getElementById('primaryStatus').textContent = 'Existing fingerprint (toggle to replace)';
                        document.getElementById('primaryStatus').className = 'text-success';
                    }
                    
                    if (emp.has_backup_fingerprint) {
                        document.getElementById('captureBackupBtn').textContent = 'Replace Backup';
                        document.getElementById('captureBackupBtn').disabled = true; // Disabled by default
                        document.getElementById('backupStatus').textContent = 'Existing fingerprint (toggle to replace)';
                        document.getElementById('backupStatus').className = 'text-success';
                        document.getElementById('backupSection').style.opacity = '1';
                    } else {
                        // No backup exists, allow adding one (but still start disabled until toggle)
                        document.getElementById('backupSection').style.opacity = '1';
                        document.getElementById('captureBackupBtn').disabled = true;
                        document.getElementById('backupStatus').textContent = 'No backup fingerprint (toggle to add)';
                        document.getElementById('backupStatus').className = 'text-muted';
                    }
                    
                    // Show notification
                    showNotification(
                        'Edit Mode',
                        `Editing fingerprints for ${emp.full_name}. Capture new fingerprints to replace existing ones.`,
                        'info'
                    );
                    
                    console.log('Employee data loaded successfully');
                } else {
                    console.error('Failed to load employee:', data.message);
                    showNotification('Error', data.message || 'Failed to load employee data', 'error');
                }
            } catch (error) {
                console.error('Error loading employee:', error);
                showNotification('Error', 'Failed to load employee data: ' + error.message, 'error');
            }
        }

        async function resolveBridgeBase() {
            const candidates = [18420, 18421, 18422, 18423, 18424].map(p => `http://127.0.0.1:${p}`);
            for (const base of candidates) {
                try {
                    const r = await fetch(`${base}/api/health/ping`, { method: 'GET', signal: AbortSignal.timeout(2000) });
                    if (r.ok) { bridgeBase = base; return base; }
                } catch (_) { /* try next */ }
            }
            return candidates[0];
        }

        const deviceStatus = document.getElementById('deviceStatus');
        const registerBtn = document.getElementById('registerBtn');
        const registerHint = document.getElementById('registerHint');

        // Primary fingerprint elements
        const capturePrimaryBtn = document.getElementById('capturePrimaryBtn');
        const primaryStatus = document.getElementById('primaryStatus');
        const primaryTemplate = document.getElementById('primaryTemplate');
        const primaryProgress = document.getElementById('primaryProgress');
        const primaryProgressBar = document.getElementById('primaryProgressBar');
        const primaryInstruction = document.getElementById('primaryInstruction');

        // Backup fingerprint elements
        const captureBackupBtn = document.getElementById('captureBackupBtn');
        const backupStatus = document.getElementById('backupStatus');
        const backupTemplate = document.getElementById('backupTemplate');
        const backupProgress = document.getElementById('backupProgress');
        const backupProgressBar = document.getElementById('backupProgressBar');
        const backupInstruction = document.getElementById('backupInstruction');
        const backupSection = document.getElementById('backupSection');

        // Other elements
        const fpOverallStatus = document.getElementById('fpOverallStatus');
        const rfidStatus = document.getElementById('rfidStatus');
        const rfidInput = document.getElementById('rfidUid');

        // State tracking
        let deviceConnected = false;
        let enrollmentInProgress = false;
        let primarySessionId = null;
        let backupSessionId = null;
        let primaryPollTimer = null;
        let backupPollTimer = null;
        let fingerprintDeviceModel = '';
        let primaryWasCancelled = false;
        let backupWasCancelled = false;

        // Request throttling and optimization
        let lastBridgeCheck = 0;
        let bridgeCheckInterval = 5000;
        let maxBridgeCheckInterval = 30000;
        let bridgeCheckTimer = null;
        let isCheckingBridge = false;

        // Global sanitizer for RFID text
        function sanitize(raw) {
            const original = String(raw ?? '');
            console.log('RFID Input - Raw value:', JSON.stringify(original));
            const printableOnly = original.replace(/[^\x20-\x7E]/g, '');
            const collapsed = printableOnly.replace(/\s+/g, ' ').trim();
            return collapsed;
        }

        function updateRegisterEnabled() {
            const editMode = isEditMode();
            
            if (editMode) {
                // In edit mode, check if any toggle is checked and has corresponding fingerprint captured
                const replacePrimaryChecked = document.getElementById('replacePrimaryToggle')?.checked;
                const replaceBackupChecked = document.getElementById('replaceBackupToggle')?.checked;
                const hasPrimaryFp = !!primaryTemplate.value;
                const hasBackupFp = !!backupTemplate.value;
                
                // At least one toggle must be checked AND have a captured fingerprint
                const primaryReady = replacePrimaryChecked && hasPrimaryFp;
                const backupReady = replaceBackupChecked && hasBackupFp;
                const hasAnyReplacement = primaryReady || backupReady;
                
                registerBtn.disabled = !hasAnyReplacement;
                
                if (hasAnyReplacement) {
                    registerHint.textContent = 'Ready to update fingerprints. Click Update button to proceed.';
                    registerHint.className = 'ms-2 text-success';
                } else if (!replacePrimaryChecked && !replaceBackupChecked) {
                    registerHint.textContent = 'Toggle at least one fingerprint to replace.';
                    registerHint.className = 'ms-2 text-muted';
                } else {
                    registerHint.textContent = 'Capture the selected fingerprint(s) to update.';
                    registerHint.className = 'ms-2 text-muted';
                }
            } else {
                // Register mode: require all fields
                const empName = document.getElementById('empName').value.trim();
                const empId = document.getElementById('empId').value.trim();
                const rfid = (rfidInput?.value || '').trim();
                const deptId = (document.getElementById('departmentId')?.value || '').trim();
                const empType = (document.getElementById('employmentType')?.value || '').trim();
                const hasPrimaryFp = !!primaryTemplate.value;

                const ok = empName && empId && deptId && empType && hasPrimaryFp && rfid.length > 0;
                registerBtn.disabled = !ok;

                if (ok) {
                    registerHint.textContent = 'Ready to submit. Click Register button to proceed.';
                    registerHint.className = 'ms-2 text-success';
                } else if (!hasPrimaryFp) {
                    registerHint.textContent = 'Primary fingerprint is required.';
                    registerHint.className = 'ms-2 text-muted';
                } else if (!rfid) {
                    registerHint.textContent = 'RFID scan is required.';
                    registerHint.className = 'ms-2 text-muted';
                } else {
                    registerHint.textContent = 'Please fill all required fields.';
                    registerHint.className = 'ms-2 text-muted';
                }
            }
        }

        function updateFingerprintStatus() {
            const hasPrimary = !!primaryTemplate.value;
            const hasBackup = !!backupTemplate.value;

            if (hasPrimary && hasBackup) {
                fpOverallStatus.textContent = 'Both fingerprints captured successfully.';
                fpOverallStatus.className = 'text-success fw-bold';
            } else if (hasPrimary) {
                fpOverallStatus.textContent = 'Primary fingerprint captured. Backup fingerprint is optional.';
                fpOverallStatus.className = 'text-primary';
            } else if (deviceConnected) {
                fpOverallStatus.textContent = 'Primary fingerprint required to proceed.';
                fpOverallStatus.className = 'text-muted';
            } else {
                fpOverallStatus.textContent = 'Device Bridge connection required.';
                fpOverallStatus.className = 'text-danger';
            }
        }

        function updateUIBasedOnDeviceStatus() {
            console.log('Updating UI - Device connected:', deviceConnected, 'Model:', fingerprintDeviceModel);

            const editMode = isEditMode();

            if (deviceConnected && !enrollmentInProgress) {
                deviceStatus.textContent = `${fingerprintDeviceModel} detected and ready.`;
                deviceStatus.className = 'text-success status-text';

                if (editMode) {
                    // Edit mode: buttons controlled by toggles
                    const replacePrimaryChecked = document.getElementById('replacePrimaryToggle')?.checked || false;
                    const replaceBackupChecked = document.getElementById('replaceBackupToggle')?.checked || false;

                    // Primary button: only enable if toggle is checked
                    capturePrimaryBtn.disabled = !replacePrimaryChecked;
                    
                    // Backup button: only enable if toggle is checked
                    captureBackupBtn.disabled = !replaceBackupChecked;

                    // Keep backup section fully visible in edit mode
                    backupSection.style.opacity = '1';

                } else {
                    // Register mode: normal flow
                    if (!primaryTemplate.value) {
                        capturePrimaryBtn.disabled = false;
                        primaryStatus.textContent = primaryWasCancelled ? 'Ready (cancelled)' : 'Ready to scan';
                        primaryStatus.className = primaryWasCancelled ? 'text-warning' : 'text-success';
                    } else {
                        capturePrimaryBtn.disabled = false;
                        primaryStatus.textContent = 'Captured ✓';
                        primaryStatus.className = 'text-success';
                    }

                    if (primaryTemplate.value && !backupTemplate.value) {
                        captureBackupBtn.disabled = false;
                        backupStatus.textContent = backupWasCancelled ? 'Ready (cancelled)' : 'Ready to scan';
                        backupStatus.className = backupWasCancelled ? 'text-warning' : 'text-success';
                        backupSection.style.opacity = '1';
                    } else if (backupTemplate.value) {
                        captureBackupBtn.disabled = false;
                        backupStatus.textContent = 'Captured ✓';
                        backupStatus.className = 'text-success';
                        backupWasCancelled = false;
                    } else {
                        captureBackupBtn.disabled = true;
                        backupStatus.textContent = 'Complete primary fingerprint first';
                        backupStatus.className = 'text-muted';
                        backupSection.style.opacity = '0.5';
                    }
                }
            } else if (!deviceConnected) {
                deviceStatus.textContent = 'Fingerprint device not detected.';
                deviceStatus.className = 'text-danger status-text';

                capturePrimaryBtn.disabled = true;
                captureBackupBtn.disabled = true;

                primaryStatus.textContent = 'Device not available';
                primaryStatus.className = 'text-danger';

                backupStatus.textContent = 'Device not available';
                backupStatus.className = 'text-danger';
                
                if (!editMode) {
                    backupSection.style.opacity = '0.5';
                }
            } else if (enrollmentInProgress) {
                capturePrimaryBtn.disabled = true;
                captureBackupBtn.disabled = true;
            }

            updateFingerprintStatus();
            updateRegisterEnabled();
        }

        async function checkBridge() {
            if (isCheckingBridge) return;

            const now = Date.now();
            if (now - lastBridgeCheck < 2000) return;

            isCheckingBridge = true;
            lastBridgeCheck = now;

            try {
                console.log('Checking Device Bridge...');

                const healthResponse = await fetch(`${bridgeBase}/api/health/ping`, {
                    method: 'GET',
                    signal: AbortSignal.timeout(3000)
                });

                if (!healthResponse.ok) throw new Error('Bridge not responding');

                console.log('Bridge is running, checking devices...');

                const deviceResponse = await fetch(`${bridgeBase}/api/devices`, {
                    method: 'GET',
                    signal: AbortSignal.timeout(3000)
                });

                if (!deviceResponse.ok) throw new Error('Failed to get device status');

                const deviceData = await deviceResponse.json();
                console.log('Device data received:', deviceData);

                const fpPresent = deviceData?.device?.present === true;
                const fpModel = deviceData?.device?.model || 'Unknown Device';

                const wasConnected = deviceConnected;
                deviceConnected = fpPresent;
                fingerprintDeviceModel = fpModel;

                console.log('Device status changed:', wasConnected, '->', deviceConnected);

                if (deviceConnected) {
                    bridgeCheckInterval = Math.min(bridgeCheckInterval * 0.8, 10000);
                } else {
                    bridgeCheckInterval = Math.min(bridgeCheckInterval * 1.2, maxBridgeCheckInterval);
                }

                updateUIBasedOnDeviceStatus();

            } catch (error) {
                console.error('Bridge check failed:', error);

                const wasConnected = deviceConnected;
                deviceConnected = false;
                fingerprintDeviceModel = '';

                bridgeCheckInterval = Math.min(bridgeCheckInterval * 1.5, maxBridgeCheckInterval);

                deviceStatus.textContent = 'Device Bridge not running on this PC.';
                deviceStatus.className = 'text-danger status-text';

                fpOverallStatus.textContent = 'Device Bridge connection failed.';
                fpOverallStatus.className = 'text-danger';

                if (wasConnected !== deviceConnected) {
                    updateUIBasedOnDeviceStatus();
                }
            } finally {
                isCheckingBridge = false;

                if (bridgeCheckTimer) {
                    clearTimeout(bridgeCheckTimer);
                }
                bridgeCheckTimer = setTimeout(checkBridge, bridgeCheckInterval);
            }
        }

        async function enrollFingerprint(isPrimary = true) {
            const statusElement = isPrimary ? primaryStatus : backupStatus;
            const progressElement = isPrimary ? primaryProgress : backupProgress;
            const progressBarElement = isPrimary ? primaryProgressBar : backupProgressBar;
            const instructionElement = isPrimary ? primaryInstruction : backupInstruction;
            const templateElement = isPrimary ? primaryTemplate : backupTemplate;
            const fingerType = isPrimary ? 'index finger' : 'thumb';

            enrollmentInProgress = true;
            if (isPrimary) {
                primaryWasCancelled = false;
            } else {
                backupWasCancelled = false;
            }
            updateUIBasedOnDeviceStatus();

            progressElement.classList.remove('d-none');
            statusElement.textContent = 'Initializing...';
            statusElement.className = isPrimary ? 'text-primary' : 'text-secondary';
            progressBarElement.style.width = '0%';
            instructionElement.textContent = `Initializing scanner for ${fingerType}...`;

            let sessionId = null;
            let pollTimer = null;
            let lastProgress = 0;
            let scanCount = 0;
            let enrollmentSuccessful = false;

            try {
                instructionElement.textContent = `Place your ${fingerType} on the scanner...`;
                statusElement.textContent = 'Waiting for finger...';
                progressBarElement.style.width = '10%';

                const startResp = await fetch(`${bridgeBase}/api/fingerprint/enroll/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        mode: 'dpfj',
                        requiredScans: 4
                    }),
                    signal: AbortSignal.timeout(5000)
                });
                if (!startResp.ok) throw new Error(await startResp.text().catch(() => 'Failed to start enrollment'));
                const startData = await startResp.json();
                sessionId = startData.sessionId;
                if (!sessionId) throw new Error('No sessionId from Device Bridge');

                if (isPrimary) {
                    primarySessionId = sessionId;
                } else {
                    backupSessionId = sessionId;
                }
                updateUIBasedOnDeviceStatus();

                const pollIntervalMs = 1000;
                const maxDurationMs = 35000;
                const startedAt = Date.now();

                await new Promise((resolve, reject) => {
                    pollTimer = setInterval(async () => {
                        try {
                            if (Date.now() - startedAt > maxDurationMs) {
                                clearInterval(pollTimer);
                                reject(new Error('Enrollment timeout'));
                                return;
                            }

                            const pollResp = await fetch(`${bridgeBase}/api/fingerprint/enroll/progress/${sessionId}`, {
                                method: 'GET',
                                signal: AbortSignal.timeout(3000)
                            });

                            if (!pollResp.ok) {
                                clearInterval(pollTimer);
                                reject(new Error('Failed to poll enrollment status'));
                                return;
                            }

                            const pollData = await pollResp.json();
                            console.log('Poll data:', pollData);

                            // Update progress based on actual data from bridge
                            const currentProgress = Math.max(0, Math.min(100, Number(pollData.progress) || 0));
                            const scansLeft = typeof pollData.scansLeft === 'number' ? pollData.scansLeft : null;
                            
                            // Calculate progress based on scans if available
                            if (scansLeft !== null) {
                                const scansCompleted = 4 - scansLeft;
                                const accurateProgress = (scansCompleted / 4) * 100;
                                if (accurateProgress > lastProgress) {
                                    lastProgress = accurateProgress;
                                    progressBarElement.style.width = `${accurateProgress}%`;
                                }
                                
                                if (scansCompleted > scanCount) {
                                    scanCount = scansCompleted;
                                    console.log(`Scan ${scanCount} of 4 completed`);
                                }
                            } else if (currentProgress > lastProgress) {
                                lastProgress = currentProgress;
                                progressBarElement.style.width = `${currentProgress}%`;
                            }

                            // Update status message
                            statusElement.textContent = pollData.message || (pollData.phase === 'processing' ? 'Processing...' : 'Scanning...');
                            
                            // Update instruction text
                            if (scansLeft !== null && scansLeft > 0) {
                                const scansCompleted = 4 - scansLeft;
                                instructionElement.textContent = `Lift and place your ${fingerType} again... (${scansCompleted}/4 scans completed, ${scansLeft} more needed)`;
                            } else if (pollData.done) {
                                instructionElement.textContent = `${fingerType.charAt(0).toUpperCase() + fingerType.slice(1)} enrolled successfully! (4/4 scans completed)`;
                            } else if (pollData.failed) {
                                instructionElement.textContent = `Failed to enroll ${fingerType}. Please try again.`;
                            } else if (pollData.phase === 'waiting') {
                                instructionElement.textContent = `Place your ${fingerType} on the scanner...`;
                            }

                            // Check for cancellation
                            if (pollData.cancelled || (pollData.message && pollData.message.toLowerCase().includes('cancelled'))) {
                                clearInterval(pollTimer);
                                pollTimer = null;
                                enrollmentSuccessful = false;
                                templateElement.value = '';
                                progressBarElement.style.width = '0%';
                                statusElement.textContent = 'Cancelled';
                                statusElement.className = 'text-warning';
                                instructionElement.textContent = 'Enrollment cancelled.';
                                if (isPrimary) {
                                    primaryWasCancelled = true;
                                } else {
                                    backupWasCancelled = true;
                                }
                                return resolve(); // Resolve to prevent error handling
                            }

                            // Check for failure
                            if (pollData.failed) {
                                clearInterval(pollTimer);
                                pollTimer = null;
                                return reject(new Error(pollData.message || 'Enrollment failed'));
                            }

                            // Check for completion
                            if (pollData.done) {
                                clearInterval(pollTimer);
                                pollTimer = null;
                                
                                // Call finish endpoint to get the final template
                                try {
                                    const finishResp = await fetch(`${bridgeBase}/api/fingerprint/enroll/finish/${sessionId}`, {
                                        method: 'POST',
                                        headers: {
                                            'Accept': 'application/json'
                                        },
                                        signal: AbortSignal.timeout(4000)
                                    });
                                    
                                    if (!finishResp.ok) {
                                        throw new Error('Failed to finalize enrollment');
                                    }
                                    
                                    const finishData = await finishResp.json();
                                    console.log('Finish data:', finishData);
                                    
                                    if (!finishData.template) {
                                        throw new Error('No template returned');
                                    }
                                    
                                    templateElement.value = finishData.template;
                                    progressBarElement.style.width = '100%';
                                    statusElement.textContent = `${isPrimary ? 'Primary' : 'Backup'} fingerprint captured successfully!`;
                                    statusElement.className = 'text-success fw-bold';
                                    enrollmentSuccessful = true;
                                    
                                    return resolve();
                                } catch (finishError) {
                                    console.error('Finish enrollment error:', finishError);
                                    return reject(new Error('Failed to finalize: ' + finishError.message));
                                }
                            }
                        } catch (err) {
                            console.error('Poll error:', err);
                            clearInterval(pollTimer);
                            pollTimer = null;
                            reject(err);
                        }
                    }, pollIntervalMs);
                });

                if (enrollmentSuccessful) {
                    showNotification(
                        'Fingerprint Captured',
                        `${fingerType.charAt(0).toUpperCase() + fingerType.slice(1)} enrolled successfully!`,
                        'success'
                    );
                }
            } catch (error) {
                console.error('Enrollment error:', error);
                progressBarElement.style.width = '0%';
                statusElement.textContent = `Failed: ${error.message}`;
                statusElement.className = 'text-danger';
                instructionElement.textContent = `Failed to enroll ${fingerType}. Please try again.`;
                showNotification('Fingerprint Enrollment Failed', `Could not capture ${fingerType}: ${error.message}`, 'error');
            } finally {
                if (pollTimer) {
                    clearInterval(pollTimer);
                }
                enrollmentInProgress = false;

                if (statusElement.className.includes('text-danger')) {
                    setTimeout(() => {
                        progressElement.classList.add('d-none');
                        progressBarElement.style.width = '0%';
                    }, 1200);
                } else {
                    setTimeout(() => {
                        progressElement.classList.add('d-none');
                    }, 2000);
                }

                setTimeout(updateUIBasedOnDeviceStatus, 300);
            }
        }

        function showNotification(title, message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `alert alert-${type === 'error' ? 'danger' : type === 'success' ? 'success' : 'info'} alert-dismissible fade show position-fixed notification`;
            notification.style.cssText = 'top: 20px; right: 20px; z-index: 9999; max-width: 400px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);';

            notification.innerHTML = `
                <div class="d-flex align-items-start">
                    <div class="me-2">
                        <i class="bi ${type === 'success' ? 'bi-check-circle-fill' : type === 'error' ? 'bi-exclamation-triangle-fill' : 'bi-info-circle-fill'} fs-4"></i>
                    </div>
                    <div class="flex-grow-1">
                        <strong>${title}</strong><br>
                        <span>${message}</span>
                    </div>
                    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                </div>
            `;

            document.body.appendChild(notification);

            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 5000);
        }

        // Event listeners
        capturePrimaryBtn?.addEventListener('click', () => enrollFingerprint(true));
        captureBackupBtn?.addEventListener('click', () => enrollFingerprint(false));

        // Toggle handlers for edit mode
        document.getElementById('replacePrimaryToggle')?.addEventListener('change', (e) => {
            const isChecked = e.target.checked;
            const btn = document.getElementById('capturePrimaryBtn');
            
            if (isChecked) {
                btn.disabled = !deviceConnected;
                document.getElementById('primaryStatus').textContent = 'Ready to scan replacement';
                document.getElementById('primaryStatus').className = 'text-primary';
            } else {
                btn.disabled = true;
                document.getElementById('primaryStatus').textContent = 'Existing fingerprint (toggle to replace)';
                document.getElementById('primaryStatus').className = 'text-success';
                // Clear any captured template if toggle is unchecked
                document.getElementById('primaryTemplate').value = '';
            }
            updateRegisterEnabled();
        });

        document.getElementById('replaceBackupToggle')?.addEventListener('change', (e) => {
            const isChecked = e.target.checked;
            const btn = document.getElementById('captureBackupBtn');
            
            if (isChecked) {
                btn.disabled = !deviceConnected;
                document.getElementById('backupStatus').textContent = 'Ready to scan replacement';
                document.getElementById('backupStatus').className = 'text-secondary';
            } else {
                btn.disabled = true;
                document.getElementById('backupStatus').textContent = 'Existing fingerprint (toggle to replace)';
                document.getElementById('backupStatus').className = 'text-success';
                // Clear any captured template if toggle is unchecked
                document.getElementById('backupTemplate').value = '';
            }
            updateRegisterEnabled();
        });

        // Cancel button - closes the tab
        document.getElementById('cancelBtn')?.addEventListener('click', () => {
            window.close();
        });

        rfidInput?.addEventListener('focus', () => {
            rfidInput.select();
        });

        document.getElementById('clearRfidBtn')?.addEventListener('click', () => {
            rfidInput.value = '';
            rfidStatus.textContent = '';
            rfidStatus.classList.add('text-muted');
            rfidInput.focus();
            updateRegisterEnabled();
        });

        // RFID input handling
        if (rfidInput) {
            let lastTs = 0;
            let burstCount = 0;
            const burstWindowMs = 400;
            const minBurst = 4;

            rfidInput.addEventListener('keydown', (e) => {
                const now = performance.now();
                if (now - lastTs < 35) {
                    burstCount++;
                } else if (now - lastTs > burstWindowMs) {
                    burstCount = 0;
                }
                lastTs = now;
            });

            rfidInput.addEventListener('input', (e) => {
                try {
                    const sanitized = sanitize(e.target.value);
                    if (sanitized !== e.target.value) {
                        const cursorPos = e.target.selectionStart;
                        e.target.value = sanitized;
                        e.target.setSelectionRange(cursorPos, cursorPos);
                    }

                    if (sanitized.length > 0) {
                        rfidStatus.textContent = '✓ Scanned';
                        rfidStatus.className = 'ms-2 small text-success';
                    } else {
                        rfidStatus.textContent = '';
                        rfidStatus.className = 'ms-2 small text-muted';
                    }

                    updateRegisterEnabled();
                } catch (error) {
                    console.error('RFID input error:', error);
                }
            });

            rfidInput.addEventListener('paste', (e) => {
                setTimeout(() => {
                    const sanitized = sanitize(rfidInput.value);
                    rfidInput.value = sanitized;
                    if (sanitized.length > 0) {
                        rfidStatus.textContent = '✓ Scanned';
                        rfidStatus.className = 'ms-2 small text-success';
                    }
                    updateRegisterEnabled();
                    console.log('RFID pasted, but auto-registration is disabled');
                }, 10);
            });

            setTimeout(() => rfidInput.focus(), 100);
        }

        // Form submission via AJAX to backend
        document.getElementById('registerForm')?.addEventListener('submit', async (e) => {
            e.preventDefault();

            if (registerBtn.disabled) {
                showNotification('Error', 'Please complete required fields first.', 'error');
                return;
            }

            // Validate authentication
            const token = getAuthToken();
            if (!token) {
                showNotification(
                    'Authentication Required',
                    'You are not authorized. Please log in again and provide your authentication token.',
                    'error'
                );
                return;
            }

            const originalText = registerBtn.innerHTML;
            registerBtn.innerHTML = '<i class="bi bi-hourglass-split me-1"></i> Processing...';
            registerBtn.disabled = true;

            try {
                const backendUrl = getBackendUrl();
                const editMode = isEditMode();
                
                if (editMode) {
                    // Edit mode: update fingerprints only
                    const employeeId = getEmployeeIdFromUrl();
                    
                    // Check toggle states
                    const replacePrimaryChecked = document.getElementById('replacePrimaryToggle')?.checked;
                    const replaceBackupChecked = document.getElementById('replaceBackupToggle')?.checked;
                    const hasPrimary = !!primaryTemplate.value;
                    const hasBackup = !!backupTemplate.value;
                    
                    // Validate that if a toggle is checked, the corresponding template must exist
                    if (replacePrimaryChecked && !hasPrimary) {
                        showNotification('Error', 'Please capture the primary fingerprint.', 'error');
                        registerBtn.innerHTML = originalText;
                        registerBtn.disabled = false;
                        return;
                    }
                    
                    if (replaceBackupChecked && !hasBackup) {
                        showNotification('Error', 'Please capture the backup fingerprint.', 'error');
                        registerBtn.innerHTML = originalText;
                        registerBtn.disabled = false;
                        return;
                    }
                    
                    if (!replacePrimaryChecked && !replaceBackupChecked) {
                        showNotification('Error', 'Please toggle at least one fingerprint to replace.', 'error');
                        registerBtn.innerHTML = originalText;
                        registerBtn.disabled = false;
                        return;
                    }
                    
                    const payload = {
                        token: token,
                        employee_id: employeeId,
                        replace_primary: replacePrimaryChecked,
                        replace_backup: replaceBackupChecked,
                        primary_template: replacePrimaryChecked && hasPrimary ? primaryTemplate.value : null,
                        backup_template: replaceBackupChecked && hasBackup ? backupTemplate.value : null,
                    };
                    
                    console.log('Updating fingerprints for employee:', employeeId);
                    console.log('Replace primary:', replacePrimaryChecked, 'Replace backup:', replaceBackupChecked);
                    
                    const response = await fetch(`${backendUrl}/api/update-fingerprints`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json',
                        },
                        body: JSON.stringify(payload)
                    });
                    
                    const result = await response.json();
                    
                    if (response.ok && result.success) {
                        showNotification(
                            'Update Successful',
                            `Fingerprints updated successfully for ${result.employee?.name || 'employee'}!`,
                            'success'
                        );
                        
                        // Show success message with option to close tab
                        setTimeout(() => {
                            if (confirm('Fingerprints updated successfully! Click OK to close this tab and return to the employee list.')) {
                                // Try to close the tab (works if opened via window.open or target="_blank")
                                window.close();
                                
                                // If window.close() doesn't work (some browsers block it), redirect back
                                setTimeout(() => {
                                    window.location.href = `${backendUrl}/employees`;
                                }, 100);
                            } else {
                                // User chose not to close, just show a button to go back
                                showNotification(
                                    'Update Complete',
                                    'You can now close this tab manually or click the button below to return.',
                                    'info'
                                );
                                
                                // Add a "Return to Employees" button
                                const returnBtn = document.createElement('button');
                                returnBtn.className = 'btn btn-primary btn-lg mt-3';
                                returnBtn.innerHTML = '<i class="bi bi-arrow-left me-2"></i>Return to Employee List';
                                returnBtn.onclick = () => {
                                    window.location.href = `${backendUrl}/employees`;
                                };
                                
                                const formContainer = document.getElementById('registerForm').parentElement;
                                formContainer.insertBefore(returnBtn, formContainer.firstChild);
                            }
                        }, 1500);
                    } else {
                        const errorMessage = result.message || 'Update failed. Please try again.';
                        showNotification('Update Failed', errorMessage, 'error');
                    }
                    
                } else {
                    // Register mode: create new employee
                    const rfidValue = sanitize(rfidInput?.value || '');
                    rfidInput.value = rfidValue;
                    console.log('Submitting RFID value (sanitized):', JSON.stringify(rfidValue));

                    const formData = new FormData(document.getElementById('registerForm'));

                    console.log('Form submission data:');
                    for (let [key, value] of formData.entries()) {
                        if (key !== 'primary_template' && key !== 'backup_template') {
                            console.log(`${key}:`, value);
                        } else {
                            console.log(`${key}: [${value.length} bytes]`);
                        }
                    }
                    
                    // Submit to backend API with token authentication (no CSRF needed)
                    const response = await fetch(`${backendUrl}/api/register-employee`, {
                        method: 'POST',
                        body: formData,
                        headers: {
                            'Accept': 'application/json',
                            'Authorization': `Bearer ${token}` // Include token for authentication
                        }
                    });

                    const result = await response.json();

                    // Handle authentication errors
                    if (response.status === 401 || response.status === 403) {
                        showNotification(
                            'Authorization Failed',
                            'You are not authorized. Please log in again with a valid token.',
                            'error'
                        );
                        clearAuthToken();
                        registerBtn.innerHTML = originalText;
                        updateRegisterEnabled();
                        return;
                    }

                    if (response.ok && result.success) {
                        showNotification(
                            'Registration Successful',
                            `Employee ${result.employee?.name || 'registered'} successfully!`,
                            'success'
                        );

                        setTimeout(() => {
                            document.getElementById('registerForm').reset();
                            primaryTemplate.value = '';
                            backupTemplate.value = '';
                            document.getElementById('profilePreview').classList.add('d-none');
                            document.getElementById('profilePreview').src = '';
                            rfidStatus.textContent = '';
                            primaryStatus.textContent = 'Ready to scan';
                            backupStatus.textContent = 'Complete primary fingerprint first';
                            backupSection.style.opacity = '0.5';
                            
                            // Reset office dropdown to "Select office"
                            const officeSelect = document.getElementById('departmentId');
                            if (officeSelect && officeSelect.options.length > 0) {
                                officeSelect.selectedIndex = 0;
                            }
                            
                            updateRegisterEnabled();
                            updateUIBasedOnDeviceStatus();
                            rfidInput.focus();
                        }, 1500);

                    } else {
                        const errorMessage = result.message || 'Registration failed. Please try again.';
                        const errors = result.errors || {};
                        let errorDetails = errorMessage;

                        if (Object.keys(errors).length > 0) {
                            errorDetails += '<br><ul class="mb-0 mt-1">';
                            for (const [field, messages] of Object.entries(errors)) {
                                errorDetails += `<li>${messages.join(', ')}</li>`;
                            }
                            errorDetails += '</ul>';
                        }

                        showNotification('Registration Failed', errorDetails, 'error');
                    }
                }

            } catch (error) {
                console.error('Operation error:', error);
                let errorMessage = error.message || 'An error occurred. Please try again.';

                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    errorMessage = 'Cannot connect to backend server. Please check your network connection and backend URL configuration.';
                }

                showNotification('Operation Failed', errorMessage, 'error');
            } finally {
                setTimeout(() => {
                    registerBtn.innerHTML = originalText;
                    updateRegisterEnabled();
                }, 1000);
            }
        });

        // Profile image preview
        const profileImage = document.getElementById('profileImage');
        const profilePreview = document.getElementById('profilePreview');
        profileImage?.addEventListener('change', () => {
            const f = profileImage.files && profileImage.files[0];
            if (!f) {
                profilePreview.classList.add('d-none');
                profilePreview.src = '';
                return;
            }
            const url = URL.createObjectURL(f);
            profilePreview.src = url;
            profilePreview.classList.remove('d-none');
        });

        // Re-evaluate enabling when fields change
        ['empName', 'empId', 'departmentId', 'employmentType'].forEach(id => {
            document.getElementById(id)?.addEventListener('input', updateRegisterEnabled);
            document.getElementById(id)?.addEventListener('change', updateRegisterEnabled);
        });

        registerBtn?.addEventListener('click', () => {
            updateRegisterEnabled();
        });

        // Initial checks
        setTimeout(() => {
            // Check if token is in URL
            const urlToken = getTokenFromUrl();
            const editMode = isEditMode();
            const employeeId = getEmployeeIdFromUrl();
            
            if (urlToken) {
                console.log('Token found in URL');
                
                if (editMode && employeeId) {
                    // Edit mode: load employee data
                    console.log('Edit mode detected, loading employee:', employeeId);
                    loadEmployeeData();
                } else {
                    // Register mode: load offices
                    console.log('Register mode, loading offices...');
                    loadOfficesFromBackend();
                }
            } else {
                // No token in URL - disable functionality
                console.log('No token in URL. User needs to open from admin panel.');
                
                // Clear any old tokens
                clearAuthToken();
                
                const officeSelect = document.getElementById('departmentId');
                officeSelect.innerHTML = '<option value="">Open from admin panel first</option>';
                officeSelect.disabled = true;
            }
            
            checkBridge();
            updateUIBasedOnDeviceStatus();
        }, 100);

        bridgeCheckTimer = setTimeout(checkBridge, bridgeCheckInterval);
    </script>
</body>
</html>
